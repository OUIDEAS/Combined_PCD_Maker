%==========================================================================
%                            Travis Moleski
%
%                     FILE CREATION DATE: 10/11/2022
%
%                             lidar2Geo.m
%
% This program looks at a ROSBAG generated by the Ohio University van and
% creates a point cloud
%
%==========================================================================


%% Clear & Setup Workspace

clc; 
clear; 
close all;
format compact

%% Options

% Ouster provides some options beyond intensity - it includes an IR sensor
% as well. These are the available options to 'color' the point cloud:
% 'intensity' 'reflectivity' 'ambient' 'range'
% Uncomment one of the four! (default is intensity)
int_data_string = 'intensity';
% int_data_string = 'reflectivity';
% int_data_string = 'ambient';
% int_data_string = 'range';

% minimum/maximum distance from LiDAR point of origin to include/exclude
use_dist_bool               = 0;
min_dist                    = 2;
max_dist                    = 20;

% Include which rings in final map
use_ring_bool               = 0;
ring_max                    = 127; % higher pointed lazer - max 127
ring_min                    = 64; % lower pointed lazer - min 0


%% Variable Initiation

% Lidar/IMU Reference Frames. NOTE: This uses the Velodyne's Reference
% Frame. Will need to be updated at some point for better accuracy.
LiDAR_Ref_Frame             = [0; 1.584; 1.444];
IMU_Ref_Frame               = [0; 0.336; -0.046];

% Setting the offset from the gps orientation to the lidar
% takes gps emu to local frame of lidar
gps2lidar = [ cosd(90) sind(90) 0;
             -sind(90) cosd(90) 0;
             0       0          1]; 
         
% Setting the (gps_to_lidar_diff) offset from the lidar offset to the gps
LidarOffset2gps = [ cosd(90) -sind(90)  0;
              sind(90)  cosd(90)   0;
              0        0           1]; 

% Correction frame:         LiDAR_Ref_Frame - IMU_Ref_Frame [Y X Z]
gps_to_lidar_diff           = [(LiDAR_Ref_Frame(1) - IMU_Ref_Frame(1)), (LiDAR_Ref_Frame(2) - IMU_Ref_Frame(2)), (LiDAR_Ref_Frame(3) - IMU_Ref_Frame(3))]; 

% distance traveled
gps_dist_traveled = [];

% filename init
time_now        = datetime("now","Format","uuuuMMddhhmmss");
time_now        = datestr(time_now,'yyyyMMddhhmmss');
file_p1         = 'point_cloud_source_' + string(time_now) + '.bag';

%% Loading the ROSBAG

% Location of rosbag
% bag_file = '/home/autobuntu/Documents/temp_rosbag/2023-06-07-10-08-37.bag';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/qualityInspectionPropsal-06062023/potholes/2023-06-06-16-39-15.bag'; 
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/qualityInspectionPropsal-06062023/roughroad/2023-06-06-16-44-54.bag'; 
bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/qualityInspectionPropsal-06062023/roughroad/2023-06-06-16-44-09.bag'; 
% bag_file = '/media/autobuntu/chonk/chonk/git_repos/lidar_2_geo/Delete/reset_start_time.bag';
% pcd_export_location = '/media/autobuntu/chonk/chonk/DATA/ouster_pcd_out_test/';

% Display filesize so you know how big of a cup of coffee you can get
disp_file_size(bag_file);
disp('Loading the Bag!')

% Load the rosbag into the workspace
bag_init =  rosbag(bag_file);
disp('Bag Loaded!')

% Topics
warning('This will take some time. GRAB SOME COFFEE!');
disp('Loading Topics.....')
topics = bag_init.AvailableTopics;

gps_topic = select(bag_init,'Topic','/gps/gps');
gps_msgs = readMessages(gps_topic, 'DataFormat', 'struct');

% odom_topic = select(bag_init,'Topic','/novatel/oem7/odom');
% odom_msgs = readMessages(odom_topic, 'DataFormat', 'struct');

ouster_point_topic = select(bag_init, 'Topic', '/ouster/points');
ouster_point_msgs = readMessages(ouster_point_topic, 'DataFormat', 'struct');

% ouster_imu_topic = select(bag_init, 'Topic', '/ouster/imu');
% ouster_imu_msgs = readMessages(ouster_imu_topic, 'DataFormat', 'struct');


disp ('Topics Loaded!')


%% More Var Init

% cloud_break                 = 75;
cloud_break                 = length(ouster_point_msgs);
gps_pos_store               = zeros(cloud_break,3);
lidar_pos_store             = gps_pos_store;

time_store = [];


%% Timestamps

% Matching timestamps
% [indexes, fromTimes, toTimes, diffs] = matchTimestamps(ouster_msgs2, gps_msgs);

pcd_ts = double([]);
gps_ts = double([]);

for gps_msg_idx = 1:length(gps_msgs)
    
    gps_ts = [gps_ts; gps_topic.MessageList.Time(gps_msg_idx)];
    
end

for pcd_file_idx = 1:length(ouster_point_msgs)
    
    pcd_ts = [pcd_ts; ouster_point_topic.MessageList.Time(pcd_file_idx)];
    
end

% offset = gps_ts(1) - pcd_ts(1);

% pcd_ts_offset = pcd_ts + offset;

% Find the closest timestamp for each target timestamp
closestTimestamps = zeros(size(pcd_ts));
closestIndexes = closestTimestamps;

for i = 1:numel(pcd_ts)
    
    [~, index] = min(abs(gps_ts - pcd_ts(i)));
    closestTimestamps(i) = gps_ts(index);
    closestIndexes(i) = index;
    
end

sanity_check = [pcd_ts closestTimestamps];
sanity_check_result = sanity_check(:,1) - sanity_check(:,2);
average_sanity_check_result = mean(sanity_check_result);
% Display the results
% disp(closestIndexes);

% Find which GPS message matches the first scan
matchedGps_init             = gps_msgs{closestIndexes};


%% Initilizing the starting point

% Select reference point as first GPS reading (local)
origin = [matchedGps_init.Latitude, matchedGps_init.Longitude, matchedGps_init.Altitude];
% [xEast_init, yNorth_init, zUp_init] = latlon2local(matchedGps_init.Latitude, matchedGps_init.Longitude, matchedGps_init.Altitude, origin);


%% Doing the data

close all
clear pointCloudList rpy_out gps_pos_store lidar_pos_store
fprintf('Max time delta is %f sec \n',max(abs(sanity_check_result)));
rpy_out = [];
h = waitbar(0, "Cartographing...");

for cloud = 1:length(pcd_ts)
    
    tStart = tic;
    
    % Reading the current point cloud and matched gps coord
    current_cloud               = ouster_point_msgs{cloud};
    matched_stamp               = gps_msgs{closestIndexes(cloud)};
    
    % Converting the gps coord to xyz (m)
    [xEast, yNorth, zUp]        = latlon2local(matched_stamp.Latitude, matched_stamp.Longitude, matched_stamp.Altitude, origin);
    
    % Grabbing the angles
    roll                        = matched_stamp.Roll;
    pitch                       = matched_stamp.Pitch;
    yaw                         = matched_stamp.Track+180;
%     rpy_out = [rpy_out; roll pitch yaw];
    
    if roll == 0 && pitch == 0
        
        warning('WARNING: MISSING OR BAD ORIENTATION DATA!')
        
    end
    
    % Creating the rotation matrix
    rotate_update               = rotz(90-yaw)*roty(roll)*rotx(pitch);
     
    % Offset the gps coord by the current orientation (in this case, initial) 
    % Converts the ground truth to lidar frame
    groundTruthTrajectory       = [xEast, yNorth, zUp] * gps2lidar ;
    
    % Setting the updated difference between the lidar and gps coordiate and
    % orientation
    % Converts the offsett to the lidar frame
    gps_to_lidar_diff_update    = gps_to_lidar_diff * LidarOffset2gps * rotate_update;
    
    % Rotating the offset and adding them together
    LidarxEast                  = groundTruthTrajectory(1)  + gps_to_lidar_diff_update(1);
    LidaryNorth                 = groundTruthTrajectory(2)  + gps_to_lidar_diff_update(2);
    LidarzUp                    = groundTruthTrajectory(3)  + gps_to_lidar_diff_update(3);
    
    % Making the vector of ^^^
    lidarTrajectory             = [LidarxEast, LidaryNorth, LidarzUp];
    
    % FIELDS:
    % {'x';'y';'z';'intensity';'t';'reflectivity';'ring';'ambient';'range'}
    
    % Reading the current cloud for xyz, intensity, and ring (channel) values
    xyz_cloud                   = rosReadXYZ(current_cloud);
    ring                        = rosReadField(current_cloud, 'ring');
%     t                           = rosReadField(current_cloud, 't');  % not sure what this puppy does
    if isequal(int_data_string, 'intensity')
        int_data                    = rosReadField(current_cloud, 'intensity');
    elseif isequal(int_data_string, 'reflectivity')
        int_data                    = rosReadField(current_cloud, 'reflectivity');
    elseif isequal(int_data_string, 'ambient')
        int_data                    = rosReadField(current_cloud, 'ambient');
    elseif isequal(int_data_string, 'range')
        int_data                    = rosReadField(current_cloud, 'range');
    else
        int_data                    = rosReadField(current_cloud, 'intensity');
    end
    xyz_cloud(:,4)              = int_data;
    xyz_cloud(:,5)              = ring;
    
    % Here are options for trimming data ~~~~~~~
    if use_ring_bool
        % Eliminate points based on channel
        xyz_cloud(xyz_cloud(:,5) < ring_min, :) = [];
        xyz_cloud(xyz_cloud(:,5) > ring_max, :) = [];
    end
    
    if use_dist_bool
        % Eliminate points based on distance
        xyz_cloud(sqrt(xyz_cloud(:,1).^2 + xyz_cloud(:,2).^2 + xyz_cloud(:,3).^2) <= min_dist, :) = [];
        xyz_cloud(sqrt(xyz_cloud(:,1).^2 + xyz_cloud(:,2).^2 + xyz_cloud(:,3).^2) >= max_dist, :) = [];
    end
    
    % Eliminiating infs and nans from the xyz data
    xyz_cloud                   = xyz_cloud( ~any( isnan(xyz_cloud) | isinf(xyz_cloud), 2),:);
    
    % Sort rows
    xyz_cloud = sortrows(xyz_cloud,5);
    
    % Transforming the point cloud
    tform                       = rigid3d(rotate_update, [lidarTrajectory(1) lidarTrajectory(2) lidarTrajectory(3)]);
    
    % Creating the point cloud object3
    pointClouXYZI_curr          = pointCloud([xyz_cloud(:,1), xyz_cloud(:,2), xyz_cloud(:,3)], 'Intensity',  xyz_cloud(:,4));
    pointClouXYZI_curr          = pctransform(pointClouXYZI_curr, tform);
   
    % Storing the position
    gps_pos_store(cloud,:)      = groundTruthTrajectory;
    lidar_pos_store(cloud,:)    = lidarTrajectory;
    
    % Storing the point cloud
    pointCloudList{cloud}       = pointClouXYZI_curr;
    
%     mergeGridStep = 0.1;
%     pointCloudList = pcmerge(pointCloudList, pointClouXYZI_curr, mergeGridStep);
    
    if cloud > cloud_break
        break
    end
    
    
    %% Time to Completion Estimation
    tEnd = toc(tStart);
    time_store = [time_store; tEnd];
    time_avg = mean(time_store);
    est_time_to_complete = (time_avg * (cloud_break - cloud));
    
    
    %% Waitbar
    
    waitbar(cloud/cloud_break,h,sprintf('Cloud %d out of %d, ~ %0.1f sec left',cloud, cloud_break, est_time_to_complete))
    
    
end

delete(h)


%% Compiling the map

disp("Making the map, sire...")
pointCloudList = pccat([pointCloudList{:}]);


%% Displaying the map

figure

hold on

% Plotting the line between the lidar and gps
for point = 1:length(lidar_pos_store)
    
    plot3([lidar_pos_store(point,1) gps_pos_store(point,1)],...
          [lidar_pos_store(point,2) gps_pos_store(point,2)],...
          [lidar_pos_store(point,3) gps_pos_store(point,3)],...
          'linewidth',3)
      
end

% Plotting the lidar and gps points
scatter3(gps_pos_store(1,1),gps_pos_store(1,2),gps_pos_store(1,3),420,'^','MarkerFaceColor','green')
scatter3(gps_pos_store(end,1),gps_pos_store(end,2),gps_pos_store(end,3),420,'^','MarkerFaceColor','red')
scatter3(gps_pos_store(:,1),gps_pos_store(:,2),gps_pos_store(:,3),50,'^','MarkerFaceColor','magenta')
scatter3(lidar_pos_store(:,1),lidar_pos_store(:,2),lidar_pos_store(:,3),50,'^','MarkerFaceColor','cyan')

% Plotting the point cloud
pcshow(pointCloudList);

% Adjusting the color scale so the image looks nicer
if isequal(int_data_string, 'intensity')
    caxis([100 4500])
elseif isequal(int_data_string, 'reflectivity')
    caxis([0 250])
elseif isequal(int_data_string, 'ambient')
    caxis([0 10000])
end

view([0 0 90])

%% Length Traveled

for gps_pos_store_idx = 2:1:length(gps_pos_store)
    
    % Calculate between two points
    x_component = (gps_pos_store(gps_pos_store_idx,1) - gps_pos_store(gps_pos_store_idx-1,1))^2;
    y_component = (gps_pos_store(gps_pos_store_idx,2) - gps_pos_store(gps_pos_store_idx-1,2))^2;
    z_component = (gps_pos_store(gps_pos_store_idx,3) - gps_pos_store(gps_pos_store_idx-1,3))^2;
    dist_traveled_temp = (x_component + y_component + z_component)^(1/2);
    
    % Apphend
    gps_dist_traveled = [gps_dist_traveled; dist_traveled_temp];
    
end

tot_dist_traveled = sum(gps_dist_traveled) / 0.3048; % freedom units best units


%% Save the PCD

save_ans = questdlg('Save pcd?', 'Save pcd?', 'Yes', 'No', 'No');

switch save_ans
    
    case 'Yes'
        
        name_ans        = inputdlg({'Enter Filename:'}, 'Filename', [1 35], {'pcd.pcd'});
%         name_ans        = name_ans{:};
%         name_ans = name_ans + "_FROM_FILE_" + string(file_p1(1:end-4)) + ".pcd";
                
        export_dir      = uigetdir();
        PCDFileName     = string(fullfile(export_dir, name_ans));
        
        pcwrite(pointCloudList,PCDFileName)
        
        disp('File Saved! :D')
        
    case 'No'
        
        warning('WILL NOT SAVE THE PCD!')
        
end


%% End Program 

% web('https://www.youtube.com/watch?v=DPBvMsT3prg&ab_channel=AdesRizaTV')

disp('End Program!')

